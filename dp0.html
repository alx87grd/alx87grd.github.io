<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="description" content="test" />
<meta name="keywords" content="alexandre,girard" />
<meta name="subject" content="test" />
<meta name="classification" content="test" />
<meta name="author" content="Alexandre Girard, Sherbrooke, Québec, Canada" />
<meta name="copyright" content="Tous droits réservé à Alexandre Girard" />
<meta NAME="RATING" CONTENT="General">
<meta NAME="DISTRIBUTION" CONTENT="Global">
<title> Dynamic programming, optimal control and reinforcement learning  </title>
<link href="oldalex.css" rel="stylesheet" type="text/css" />
<!--
<link rel="shortcut icon" href="ico32.ico">
-->
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>



<body>

<div id="BACKGROUND">

</div>

<div id="ALL">


<div class="BOX" id="BANNER">
  <h2>Dynamic programming, optimal control and reinforcement learning</h2> 
      <div id="Banner_Menu">
      <p>| <a href="index.html">Home</a> | <a href="#A">A</a> | <a href="#D">Contact</a> |</p>
      </div>
  </div>
  
<div class="SUBSECTION" id="Preface">
    <h2>Preface</h2>    
  </div>

 <div class="BOX11" id="pre1">
    <p> Cette page présente des notes de cours sur les approches pour prendre des décisions intelligentes sous un cadre théorique unifié basé sur le principe de la programmation dynamique. Elle vise d'abord a établir les liens entre les approches issues du domaine de l'ingénierie (la science des asservissements et la commande optimale) et les approches issues des sciences informatiques (recherche opérationnelle et l'apprentissage par renforcement) qui ont en fait les même bases mathématiques. Ces notes visent principalement à donner à un lecteur issue du domaine de l'ingénierie les bases pour comprendre et utiliser les approches numériques issues des sciences informatiques. 
    </p>
  </div>

 <div class="BOX13L" id="pre1">
    <p> Une série de capsules vidéos associés est disponible au lien à droite:
    </p>
  </div>

<div class="BOX23L" id="pre2">
<iframe width="630" height="400" src="https://www.youtube.com/embed/videoseries?list=PL6adNeJ0A8UtNslNQfAHAzcjHcQixBSnu" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
  </div>
  

  


<div class="SUBSECTION" id="Intro">
    <h2>Introduction</h2>    
  </div>
  
  
   <div class="BOX11" id="intro1">
    <p> La programmation dynamique est un principe mathématique pour optimiser des décisions qui sont prises en séquence après avoir observé l'état d'un système. Le principe peut être utilisé autant pour analyser un système asservis classique, comme contrôler la position d'un moteur en choisissant la tension appliquée à ses bornes, que pour des problèmes probabiliste dans un contexte de finance, comme choisir quand acheter ou vendre une action en observant l'évolution de son prix, ou bien un problème d'IA comme choisir la pièce à déplacer lors d'une partie d'échec en observant la position des pièces sur l'échiquier.
    </p>
</div>


<div class="SUBSECTION" id="formulation">
    <h2>Formulation du problème</h2>    
  </div>

<div class="BOX11" id="intro1">
<h3>Un comportement défini par une loi de commande à concevoir</h3>
<p> 
On s'intéresse au problème de concevoir une \textbf{une loi de commande}, qui consiste en une fonction $c$ qui détermine l'action $u$ à prendre en fonction de l'état $x$ d'un système observé, et possiblement du temps $t$:

\begin{align}
u = c( x, t )
\end{align}

Cette loi de commande va être implémenté dans un agent qui observe l'état $x$ d'un système et agit en conséquence sur ce système pour l'influencer, formant ainsi une boucle comme illustré à la figure XXX. 

</p> 
<h3>Un objectif formulé comme la minimisation d'un coût</h3>
<p> 

Ensuite, notre loi de commande sera conçue de sorte à atteindre un objectif qui sera exprimé mathématiquement comme la minimisation d'un coût additif qui dépend de la trajectoire du système et les actions utilisée:

\begin{align}
    J=\int_0^{t_f}g(x,u,t) dt + h(x_f,t_f)
\end{align}


où $g$ est un coût cumulatif sur la trajectoire du système, $h$ est un coût terminal et $t_f$ est un horizon de temps. La forme cumulative de la fonction coût est centrale pour utiliser le principe de la programmation dynamique, mais ce n'est pas vraiment restrictif car pratiquement tout les objectifs peuvent être formulés comme la minimisation d'une fonction de coût avec cette forme. Lorsque que notre agent prend les meilleurs décisions possible en fonction de l'objectif on dira que sa loi de commande est optimale au sens qu'elle minimise la fonction de coût. 


</p>
</div>
<div class="BOX11" id="intro2">


<h3>Minimiser un coût ou maximiser une récompense?</h3>
<p>

On peut alternativement formuler l'objectif comme le problème de maximiser une récompense. Les deux approches sont équivalentes et interchangeables. Typiquement le domaine de la commande optimale utilise la formulation de minimiser un coût, qui est souvent relié à l'erreur par rapport à une trajectoire cible. Alternativement, le domaine de l'apprentissage par renforcement préfère optimiser une récompense, qui est souvent par exemple le pointage dans un jeux pour lequel une IA est développé.

</p>
</div>

<div class="SUBSECTION" id="ex">
    <h2>Exemples de contextes</h2>    
  </div>

<div class="BOX11" id="ex1">

<h3>Loi de commande pour un robot</h3>
<p>
Un exemple d'asservissement classique serait un bras robotique où l'action $u$ déterminée par la loi de commande correspond à un vecteur de couples à appliquer dans les moteurs électriques. Cette action sera calculée en fonction de l'état actuel du robot, donc ici un vecteur de positions et vitesses de ses diverses articulations. L'objectif serait formulé comme la minimisation de l'erreur de position du robot par rapport à une position cible et potentiellement d'une pénalité pour utiliser beaucoup d'énergie. Typiquement notre solution de loi de commande serait ici une équation analytique.
</p>

<h3>Algorithme de navigation</h3>
<p>
Un exemple de prise de décision à plus haut niveau serait de choisir un trajet sur une carte. La loi de commande déterminerait ici quelle direction prendre en fonction de la position actuelle sur la carte. L'objectif d'atteindre la destination le plus rapidement possible pourrait être formuler comme la minimisation du temps écoulé avant d'atteindre celle-ci. La loi de commande (qui serait une solution globale) pourrait être sous la forme d'une table de correspondance où est en mémoire la direction optimale à prendre pour chaque intersection sur laquelle on peut se trouver sur la carte.
</p>

<h3>Algorithme d'investissement</h3>
<p>
Un exemple dans un tout autre contexte serait pour un algorithme d'investissement. L'action de la loi de commande serait ici d'acheter ou non une action en fonction d'une observation de son prix. L'objectif pourrait ici être formuler comme la maximisation des gains financiers. La loi de commande serait ici un seuil de prix, qui pourrait varier en fonction du temps, en dessous duquel l'agent décide d'acheter l'action.
</p>


</p>
</div>

<div class="SUBSECTION" id="discret0">
    <h2>Formulation en temps discret</h2>    
  </div>

<div class="BOX11" id="discret">

<p>
La plupart des outils pour travailler avec ce genre de problèmes sont mieux adapté à une approche de type temps discret. Ces notes vont donc présenter les principes et les algorithmes d'abord avec une approche à temps discret ou un index $k$ indique l'étape actuelle. Il est possible de convertir une problème à temps continu en problème à temps discret en introduisant un pas de temps $dt$ et en considérant que les décisions sont prises en séquence à chaque période de temps $dt$. Alternativement, une approche pour travailler directement en temps continue est présentée à la section \ref{sec:dp_cont}. De plus, pour plusieurs types de problèmes la nature de l'évolution du système est discrètes, par exemple une partie d'échec. La formulation des problèmes en temps discret est donc très générale et s'applique a un grand nombre de problèmes.

Le problème équivalent à résoudre en temps discret est de déterminer les lois de commande $c_k$, qui dictent l'action $u$ à prendre lorsque l'état du système est de $x$ à l'étape $k$:

\begin{align}
u_k = c_k( x_k )
\end{align}

de sorte à minimiser un coût additif de la forme:

\begin{align}
    J = \sum_{k=0}^{N-1} g_k(x_k, u_k) + g_N( x_N )
\end{align}
où $N$ est l'horizon qui représente ici un nombre d'étape. De plus ici l'évolution du système est représentée par une équation de différence:
\begin{align}
    x_{k+1} = f_k( x_k, u_k)
\end{align}

Si on reforme tout le problème en une seule équation mathématique:

\begin{align}
    J^*(x_0) = \min_{c_0, ... c_k, ... c_{N-1}} 
    \left[ \sum_{k=0}^{N-1} g_k(x_k, u_k) + g_N( x_N )
    \right] \quad
    \text{avec} \quad
    x_{k+1} = f_k( x_k, c_k(x_k) )
\end{align}

on cherche les fonctions $c_k$, i.e. les loi de commandes, qui vont minimiser le coût cumulatif  sur la trajectoire du système, avec l'évolution qui est définit par une dynamique $f_k$ et les lois de commandes $c_k$.

</p>
</div>



<div class="SUBSECTION" id="algo0">
    <h2>Algorithme de programmation dynamique exacte</h2>    
  </div>

<div class="BOX11" id="algo">

\begin{align}
J^*_N(x_N) &= g_N(x_N) \\
J^*_k(x_k) &= 
\min_{u_k \in U_k(x_k)}
\left[
g_k(x_k , u_k ) + J^*_{k+1}( 
\underbrace{
f_k(x_k , u_k ) 
}_{x_{k+1}}
)
\right] \\
c^*_k(x_k) &= 
arg\min_{u_k\in U_k(x_k)}
\left[
g_k(x_k , u_k ) + J^*_{k+1}( 
\underbrace{
f_k(x_k , u_k ) 
}_{x_{k+1}}
)
\right] 
\label{eq:exactdp}
\end{align} 


</div>


<div class="SUBSECTION" id="variations">
    <h2>Variations sur un thème de programmation dynamique</h2>    
  </div>

<div class="BOX11" id="intro4">

<h3>Stochastique</h3>



\begin{align}
J^*_k(x_k) = 
\min_{u_k}
{\color{red}
E_{w_k}
}
&\left[
g_k(x_k , u_k , w_k ) + J^*_{k+1}( 
\underbrace{
f_k(x_k , u_k , w_k ) 
}_{x_{k+1}}
)
\right] 
\end{align} 


<h3>Robuste</h3>


\begin{align}
J^*_k(x_k) = 
\min_{u_k}
{\color{red}
\max_{w_k}
}
&\left[
g_k(x_k , u_k , w_k ) + J^*_{k+1}( 
\underbrace{
f_k(x_k , u_k , w_k ) 
}_{x_{k+1}}
)
\right] 
\end{align} 

<h3>À horizon de temps infini</h3>


\begin{align}
J^*(x) = 
\min_{u}
&\left[
g(x , u ) + {\color{red}\alpha} J^*( 
\underbrace{
f(x , u ) 
}_{x_{k+1}}
)
\right] 
\end{align} 


<h3>Sans modèles (apprentissage par renforcement)</h3>


\begin{align}
Q^*(x, u ) = g(x , u ) + 
\min_{u_{k+1}}
&\left[
Q^*( 
\underbrace{
f(x , u ) 
}_{x_{k+1}}
, u_{k+1}
)
\right] 
\end{align} 


<h3>À temps continu</h3>


\begin{align}
0 =
\min_{u}
\left[
g(x , u ) + \frac{\partial	J^*(x,t)}{\partial x }
\underbrace{
f(x , u , t) )
}_{\dot{x}}
\right]
\label{eq:hjb}
\end{align} 


</div>
  
 

</div>
</body>
</html>
